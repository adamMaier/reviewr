#' Report number of dropped cases when performing dplyr filter.
#' 
#' \code{filter_qc}, \code{filter_all_qc}, and \code{filter_at_qc} return
#'   identical objects as \code{filter}, \code{filter_all}, and \code{filter_at} 
#'   respectively.
#' 
#' Each _qc version of the filter functions is identical to its dplyr equivalent
#' except that it automatically prints the number of cases (i.e., rows) that do
#' not meet the filter conditions and that were thus dropped.
#' 
#' @section Scoped filtering:
#'   Currently supports two \emph{scoped} variants (\code{filter_all_qc} and 
#'   \code{filter_at_qc}) which work identical to dplyr's \code{filter_all} and
#'   \code{filter_at} but print the number of dropped rows. These scoped
#'   variants make it easy to apply a filtering condition to a selection of
#'   variables. See corresponding dplyr filter help documentation for more 
#'   details on how to use any of the filter variants.
#' 
#' @param .data A tbl.
#' @param ... Logical predicates defined in terms of the variables in `.data`.
#'   Multiple conditions are combined with `&`. Only rows where the
#'   conditon evalutes to `TRUE` are kept.
#' @param .vars_predicate A quoted predicate expression as returned by 
#'   \code{\link[dplyr]{all_vars}} or \code{\link[dplyr]{any_vars}}.
#' @param .vars A list of columns generated by \code{\link[dplyr]{vars}}, or a 
#'    character vector of column names, or a numeric vector of column positions.
#'   
#' @return An object of the same class as \code{.data}. This object will be
#'   identical to that which is returned when running the standard 
#'   \code{dplyr::filter} function or its scoped variant.
#' 
#' @seealso \code{\link[dplyr]{filter}}, and \code{\link[dplyr]{filter_all}}
#' 
#' @examples 
#' practice_data <- data.frame(A = 1:10, B = 6:15, C = 8:17)
#' 
#' # Basic filtering
#' filter_qc(practice_data, A > 5)
#' filter_qc(practice_data, A > 5 & B > 8)
#' filter_qc(practice_data, A > 5 & B > 8)
#' 
#' # Scoped filtering
#' filter_all_qc(practice_data, all_vars(. > 9))
#' filter_at_qc(practice_data, vars(B, C), any_vars(. < 15))

filter_qc <- function(.data, ...){
    
  # Counting initial rows
  init_rows <- dplyr::tally(.data)
    
  # Doing filter and counting remaining rows
  out <- dplyr::filter(.data, ...)
  final_rows <- dplyr::tally(out)
    
  # Printing filter diagnostics and returning filtered data
  message(
    init_rows - final_rows, 
    " Rows dropped (",
    round(100* (init_rows - final_rows) / init_rows, digits = 2),
    "%), after filtering on: ",
    deparse(substitute(...))
  )
    
  return(out)
    
}

#' @rdname filter_qc
filter_all_qc <- function(.tbl, .vars_predicate){
  
  # Storing initial argument
  .vars_predicate_initial <- paste(deparse(substitute(.vars_predicate)))
  
  # Adding dplyr prefix to predicate
  .vars_predicate <- eval(
    parse(text = paste0(
      "dplyr::",
      deparse(substitute(.vars_predicate)),
      collapse = ""
      )
    )
  )

  # Counting initial rows
  init_rows <- dplyr::tally(.tbl)

  # Doing filter and counting remaining rows
  out <- dplyr::filter_all(.tbl, .vars_predicate = .vars_predicate)
  final_rows <- dplyr::tally(out)

  # Printing filter diagnostics and returning filtered data
  message(
    init_rows - final_rows,
    " Rows dropped (",
    round(100* (init_rows - final_rows) / init_rows, digits = 2),
    "%), after filtering on: ",
    .vars_predicate_initial
  )

  return(out)

}

#' @rdname filter_qc
filter_at_qc <- function(.tbl, .vars, .vars_predicate){
  
  # Storing initial arguments
  .vars_initial <- paste(deparse(substitute(.vars)))
  .vars_predicate_initial <- paste(deparse(substitute(.vars_predicate)))
  
  # Adding dplyr prefix to predicate and vars
  .vars_predicate <- eval(
    parse(text = paste0(
      "dplyr::",
      deparse(substitute(.vars_predicate)),
      collapse = ""
      )
    )
  )
  if(grepl("vars\\(", deparse(substitute(.vars)))) {
    .vars <- eval(
      parse(text = paste0(
        "dplyr::",
        deparse(substitute(.vars)),
        collapse = ""
        )
      )
    )
  }
  
  # Counting initial rows
  init_rows <- dplyr::tally(.tbl)
  
  # Doing filter and counting remaining rows
  out <- dplyr::filter_at(
    .tbl, 
    .vars = .vars, 
    .vars_predicate = .vars_predicate
  )
  final_rows <- dplyr::tally(out)
  
  # Printing filter diagnostics and returning filtered data
  message(
    init_rows - final_rows,
    " Rows dropped (",
    round(100* (init_rows - final_rows) / init_rows, digits = 2),
    "%), after filtering on variables: ",
    .vars_initial,
    " with condition: ",
    .vars_predicate_initial
  )
  
  return(out)
  
}