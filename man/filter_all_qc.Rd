% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_scoped_qc.R
\name{filter_all_qc}
\alias{filter_all_qc}
\alias{filter_at_qc}
\alias{filter_if_qc}
\title{Scoped versions of filter_qc}
\usage{
filter_all_qc(.tbl, .vars_predicate, .group_check = F)

filter_at_qc(.tbl, .vars, .vars_predicate, .group_check = F)

filter_if_qc(.tbl, .predicate, .vars_predicate, .group_check = F)
}
\arguments{
\item{.tbl}{A \code{tbl} object.}

\item{.vars_predicate}{A quoted predicate expression as returned by
\code{\link[dplyr:all_vars]{all_vars()}} or \code{\link[dplyr:any_vars]{any_vars()}}.

Can also be a function or purrr-like formula. In this case, the
intersection of the results is taken by default and there's
currently no way to request the union.}

\item{.group_check}{a logical value, that when TRUE, will print a table with
each group variable and columns called "n_rows_dropped" and "percent_dropped" 
that together indicate, for each group, how many row were dropped when 
performing filter. Default is FALSE, to avoid excess printing. If data is not
grouped and .group_check = T, then an error is thrown.}

\item{.vars}{A list of columns generated by \code{\link[dplyr:vars]{vars()}},
a character vector of column names, a numeric vector of column
positions, or \code{NULL}.}

\item{.predicate}{A predicate function to be applied to the columns
or a logical vector. The variables for which \code{.predicate} is or
returns \code{TRUE} are selected. This argument is passed to
\code{\link[rlang:as_function]{rlang::as_function()}} and thus supports quosure-style lambda
functions and strings representing function names.}
}
\value{
An object of the same class as \code{.data}. This object will be
  identical to that which is returned when running the respective scoped 
  version of \code{dplyr::filter}.
}
\description{
\code{filter_all_qc}, \code{filter_at_qc}, and \code{filter_if_qc} return
  identical objects as \code{filter_all}, \code{filter_at}, and 
  \code{filter_if} respectively, except that they automatically print the
  number of cases (i.e., rows) that do not meet the filter conditions and 
  that were thus dropped.
}
\examples{
practice_data <- 
  data.frame(
    A = 1:12, 
    B = 6:17, 
    C = 8:19, 
    G = c(rep(c(1, 2), each = 6))
  )


# Scoped filtering
filter_all_qc(practice_data, all_vars(. > 9))
filter_at_qc(practice_data, vars(B, C), any_vars(. > 9))
filter_if_qc(practice_data, is.integer, all_vars(. > 3))

# With grouped data and setting .group_check = T, you can see how many rows
# were dropped per group. Note that this will print a large table if you have 
# a lot of groups.
grouped_data <- group_by(practice_data, G)
filter_all_qc(grouped_data, dplyr::all_vars(. > 9), .group_check = T)

}
\seealso{
\code{\link[dplyr]{filter_all}}
}
